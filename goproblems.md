# goproblems

## 有两个 go程，更新同一条数据，第一个更新数据之后，第二个 go程 又更新了这个数据并更新了缓存，这时第一个 go程 更新了缓存，这种情况怎么解决。

答：为什么会出现那种现象呢 更新数据再同步缓存？一种是更新数据库数据和更新缓存分开，一个是一起做

一起做属于数据强一致，这种肯定要加锁，分开来做属于弱一致，可以一个协程负责更新数据库，一个协程负责更新缓存。

还可以通过缓存为1的通道, 先取后放, 保证go协程依次进行或者缓存数据增加版本号标识, 对全局版本号维护, 更新数据与缓存的版本号一致, 当前缓存的版本号高于要用于更新的, 则不进行更新

增加版本号标识  是不是和mysql的mvcc差不多？有点像mysql的mvcc了，平时也就想到加锁和channel。加版本号 = 乐观🔒

## 微服务中，两个服务并发访问下，数据库中的数据与 redis 中的数据怎么保证一致，怎么加锁

答：抢占式调度。往redis加个🔒key 表示某个服务在用另一个服务看到这个key就会等待，服务用完后把key删了 另一个就可以写入key再调度

redis作为缓存, 请求优先从redis中获取结果普通的先更新数据库, 后更新redis, 期间会存在一个简短的时间差, 这期间访问到的redis的数据是旧数据需要强一致的话, mysql操作开锁通过先更新redis, 再更新数据库, 保证请求获得的数据就是最新的并发时, redis单核单线程, 线性安全, redis更新不用加锁